# Cursor Rules for mypos

## Mission
- Analyze the Go gRPC/Gateway project and implement business logic cleanly.
- Must use grpc-manager tools to scaffold and maintain proto/services/models.
- Write and run tests; all tests must pass before features are complete.
- If a client app exists (Vue/React/HTML+Javascript), connect to it using the existing API.

## Conventions
- IDs: use MongoDB `primitive.NewObjectID().Hex()`; store as strings in models and proto.
- Proto: include `option go_package = "mypos/pb";`; messages use Request/Response suffixes; use `google.protobuf.Timestamp` for time fields; add HTTP annotations.
- Naming: files `snake_case`; JSON fields `camelCase`; Go structs/interfaces `PascalCase`; Mongo collections `snake_case`.
- Structure: each service has its own proto and service file; generated code in `pb/`.
- Logging: shared logger with context.
- DB: use `context.Context` on all operations; create indexes for frequently queried fields; design for query patterns.

## Default Development Flow
1. Analyze requirements and code paths (prefer semantic search over raw grep).
2. Add/Update models in `models/` with constructors and defaults.
3. Define/extend proto in `proto/` with messages and RPCs + HTTP mapping.
4. Regenerate artifacts.
5. Implement repository/service logic: CRUD, pagination, filtering, soft delete, transactions if multi-doc; add model↔proto converters and validations; add logging and detailed errors.
6. Tests: unit and integration (separate test DB via env). Include positive/negative, pagination/filtering, and index coverage if applicable.
7. Register service in `server/grpc.go` and `server/gateway.go` (verify registrations after generation).
8. Re-run tests; fix regressions.
9. Connect to the client (if present) via the generated REST/gRPC endpoints.

## grpc-manager Tools
- generate_service(Service, fields)
- add_rpc(Service, RpcName, req_fields, res_fields, http, body?)
- add_nested(Service, field_name, fields, repeated?, message_name?)
- remove_service(Service)
- regenerate_proto()
- get_project_status()

Policy:
- After structural changes, immediately regenerate and verify status.
- If regeneration fails (e.g., duplicates), resolve in `proto/*.proto` then regenerate.

## Testing
- Commands: `go test -v ./...` and `go test -v ./repositories`.
- Use `testify` suite/assertions; prefer real Mongo test DB (no mocks) for repo tests.
- Cover edge cases, error handling, pagination, filtering; verify index usage when relevant.

## Repository Layer
- Separate repository per domain entity.
- Validate requests before DB ops; use aggregation pipelines for complex queries; add indexes.
- Use transactions for multi-document updates; prefer bulk ops when appropriate.
- Implement soft delete when data shouldn’t be permanently removed.
- Comprehensive logging; detailed error codes/messages and user-friendly responses.

## Security & Error Handling
- Hash passwords with bcrypt; use JWT; validate inputs; enforce access controls; secure endpoints.
- Log with context; handle failures gracefully.

## Operational Discipline in Cursor
- Prefer absolute paths for tool actions.
- Use parallel read-only searches for faster understanding.
- Maintain TODOs for multi-step changes; check off as you go.
- Run lints/diagnostics after edits; fix issues immediately.
- Proceed without blocking unless truly required; state assumptions.

## Project Commands
- Regenerate proto/gateway/OpenAPI: `make proto`

## Completion Criteria
- New features include: models, proto, generated code, repository/service logic, tests, and registrations.
- `go test -v ./...` passes.
- Protos compile and gateway/swagger regenerate cleanly.
